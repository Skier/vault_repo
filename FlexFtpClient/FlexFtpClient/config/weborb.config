<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <configSections>
    <sectionGroup name="weborb">
      <section name="logging" type="Weborb.Config.LoggingConfigHandler, weborb" />
      <section name="activators" type="Weborb.Config.ActivatorsConfigHandler, weborb" />      
      <section name="inspectors" type="Weborb.Config.InspectorsConfigHandler, weborb" />
      <section name="invokers" type="Weborb.Config.InvokersConfigHandler, weborb" />
      <section name="services" type="Weborb.Config.ServicesConfigHandler, weborb" />
      <section name="abstractClassMappings" type="Weborb.Config.AbstractMappingsConfigHandler, weborb" />      
      <section name="customWriters" type="Weborb.Config.CustomWritersConfigHandler, weborb" />            
      <section name="messageServer" type="Weborb.Server.Config.MessageServerConfig, weborb" />
      <section name="security" type="Weborb.Security.SecurityConfigHandler, weborb" />
      <section name="acl" type="Weborb.Security.AclConfigHandler, weborb" />
      <section name="callTrace" type="Weborb.Config.CallTraceConfigHandler, weborb" />
      <section name="serviceFactories" type="Weborb.Config.ServiceFactoriesConfigHandler, weborb" />
      <section name="argumentFactories" type="Weborb.Config.ArgumentFactoriesConfigHandler, weborb" />
      <section name="alternateConfigPath" type="Weborb.Config.AlternateConfigPathHandler, weborb" />
      <section name="datasets" type="Weborb.Config.DatasetConfigPathHandler, weborb" />
      <section name="protocols" type="Weborb.Config.ProtocolsConfigHandler, weborb" /> 
      <section name="classMappings" type="Weborb.Config.ClassMappingsHandler, weborb" /> 
      <section name="serialization" type="Weborb.Config.SerializationConfigHandler, weborb" />       
    </sectionGroup>
  </configSections>
  
  <weborb>
  
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========               P R O T O C O L S                   ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
  WebORB is a multi-protocol presentation server. The same server instance can process
  requests in different formats. Protocol parsers can be plugged in using the protocolHandler
  element below. Protocol handlers must implement the weborb.protocols.IMessageFactory
  interface. Interface implementations must have default no-arg constructor.
  ==================================================================================== -->
  <protocols>
        <!-- WOLF protocol handler -->
        <protocolHandler>Weborb.Protocols.Wolf.RequestParser</protocolHandler>

        <!-- AMF/ Flash Remoting protocol handler -->
        <protocolHandler>Weborb.Protocols.Amf.RequestParser</protocolHandler>
  </protocols>


  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========      C L I E N T   C L A S S   M A P P I N G      ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
  To simplify the translation between client and server-side data classes, WebORB provides a
  class mapping facility. Using the format below you can specify names of the data classes
  used on the client side and map them to the corresponding classes on the server side. These
  mappings take effect under the following conditions:
  1. When a client sends an object of a particular class as an argument to a method call
     and the server-side method's formal argument is an interface, an abstract class or 
     a generic base class. In these cases, the server-side class must be either an 
     implementation of the interface or a assignable from the specified abstract or base class.
     These mappings take the precedence over the "abstractClassMappings" configuration.
  2. When a server as a result of a method invocation returns an object of a class that has
     a mapping below, WebORB will format response such that the client-side system 
     understands which client-side class should be used  
  ==================================================================================== -->
  <classMappings>
        <classMapping>
            <clientClass>ArgumentMetadata</clientClass>
            <serverClass>Weborb.Inspection.ArgumentDescriptor</serverClass>
        </classMapping>
        <classMapping>
            <clientClass>FunctionMetadata</clientClass>
            <serverClass>Weborb.Inspection.MethodDescriptor</serverClass>
        </classMapping>
        <classMapping>
            <clientClass>ServiceMetadata</clientClass>
            <serverClass>Weborb.Inspection.ServiceDescriptor</serverClass>
        </classMapping>
        <classMapping>
            <clientClass>RecordSet</clientClass>
            <serverClass>Weborb.Reader.Dataset.DataSetInfo</serverClass>
        </classMapping>
        <classMapping>
            <clientClass>flex.messaging.messages.CommandMessage</clientClass>
            <serverClass>Weborb.V3Types.ReqMessage</serverClass>
        </classMapping>
        <classMapping>
            <clientClass>flex.messaging.messages.RemotingMessage</clientClass>
            <serverClass>Weborb.V3Types.ReqMessage</serverClass>
        </classMapping>
        <classMapping>
            <clientClass>flex.messaging.messages.AcknowledgeMessage</clientClass>
            <serverClass>Weborb.V3Types.AckMessage</serverClass>
        </classMapping>
        <classMapping>
            <clientClass>flex.data.messages.DataMessage</clientClass>
            <serverClass>Weborb.V3Types.DataMessage</serverClass>
        </classMapping>
        <classMapping>
            <clientClass>flex.data.messages.PagedMessage</clientClass>
            <serverClass>Weborb.V3Types.PagedMessage</serverClass>
        </classMapping>
        <classMapping>
            <clientClass>flex.data.messages.SequencedMessage</clientClass>
            <serverClass>Weborb.V3Types.SeqMessage</serverClass>
        </classMapping>        
        <classMapping>
            <clientClass>flex.messaging.messages.ErrorMessage</clientClass>
            <serverClass>Weborb.V3Types.ErrMessage</serverClass>
        </classMapping>
        <classMapping>
          <clientClass>flex.messaging.messages.DataErrorMessage</clientClass>
          <serverClass>Weborb.V3Types.ErrDataMessage</serverClass>
        </classMapping>    
        <classMapping>
            <clientClass>flex.data.messages.UpdateCollectionMessage</clientClass>
            <serverClass>Weborb.V3Types.UpdateCollMessage</serverClass>
        </classMapping>
        <classMapping>
            <clientClass>flex.data.UpdateCollectionRange</clientClass>
            <serverClass>Weborb.V3Types.UpdateCollRange</serverClass>
        </classMapping>         
        <classMapping>
          <clientClass>com.mc.ftp.business.Connection</clientClass>
          <serverClass>Weborb.Samples.Ftp.Connection</serverClass>
        </classMapping>
  </classMappings>

  
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========   A L T E R N A T E   C O N F I G   P A T H       ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
   When WebORB configuration is updated via Management Console, the product
   automatically attempts to save the changes. If for some reason the file cannot be 
   saved, an alternative location can be specified with the <alternateConfigPath>
   property. In most cases the reason why the original config file cannot be saved
   is because of missing security permissions.
  ==================================================================================== -->  
  <alternateConfigPath>c:\\weborb\\</alternateConfigPath>


  
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========             L O G G I N G                         ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
   WebORB logging policies and categories. Logging policies control how log events
   are displayed or persisted. Logging categories control which events are enabled
   To disable a category, change the 'enabled' attribute value to "no"
  ==================================================================================== -->
  
  <logging>
  
    <!-- enter the name of the logging policy. the name must match the value from the
    <policyName> element from one of the logging policies listed below -->
    <currentPolicy>Date Based Logging</currentPolicy>

    <!-- File Size Threshold policy - All log events are saved in a file. As soon as the
    file reaches the size specified in the <value> element of the fileSize parameter, the
    policy rolls logging over to a new file -->
    <loggingPolicy>
      <policyName>File Size Threshold</policyName>
      <className>Weborb.Util.Logging.Policies.SizeThresholdPolicy</className>
      <!-- the fileSize parameter specifies the size of the file in KB before a new file is created -->
      <parameter>
        <name>fileSize</name>
        <value>1024</value>
      </parameter>
      <!-- the fileName parameter specifies the prefix of the log file name.
      WebORB adds sequential numbers at the end of the prefix  -->
      <parameter>
        <name>fileName</name>
        <value>webORB_log</value>
      </parameter>
    </loggingPolicy>


    <!-- Date based logging - All log events are saved in a file corresponding to the
    date when the events occured. When the product is restarted, the same log file is used
    to store the log events. If the date changes while the product is running, log events
    issued on the new date are saved in a new file -->
    <loggingPolicy>
      <policyName>Date Based Logging</policyName>
      <className>Weborb.Util.Logging.Policies.DatePolicy</className>
    </loggingPolicy>

    <loggingPolicy>
      <policyName>Console</policyName>
      <className>Weborb.Util.Logging.Policies.ConsoleLoggingPolicy</className>
    </loggingPolicy>
    
    <loggingPolicy>
      <policyName>Specific File</policyName>
      <className>Weborb.Util.Logging.Policies.SpecificFilePolicy</className>
      <parameter>
        <name>fileName</name>
        <value>webORB1_log.txt</value>
      </parameter>
    </loggingPolicy>
  
    <log enable="yes">WEBORB INFO</log>
    <log enable="yes">WEBORB DEBUG</log>
    <log enable="yes">WEBORB ERROR</log>
    <log enable="yes">WEBORB SERIALIZATION</log>
    <log enable="yes">WEBORB EXCEPTION</log>
    <log enable="yes">WEBORB INSTRUMENTATION</log>
    <log enable="yes">WEBORB SECURITY</log>
    <log enable="yes">WEBORB MESSAGE SERVER</log>
    
  </logging>
    
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========           N A M E D    S E R V I C E S            ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
  Named services is a feature unique to WebORB. It allows to hide the name of the concrete
  class (type) or a web service from the flash client side. A class (type) name is mapped to a
  logical name which is used in the NetConnection.getService call.
  To create a named service definition, create a <service> element. The <name> subelement
  contains the assigned logical name. The <serviceId> element contains the name of the class,
  web service WSDL URL, EJB JNDI location, etc.
  ==================================================================================== -->
  <services>
    <!-- named services defined for console security panel -->
    <service>
        <name>flashorbHttpHandler</name>
        <serviceId>Weborb.ORBHttpHandler</serviceId>
    </service>

    <service>
        <name>flashorbInspector</name>
        <serviceId>Weborb.Dispatch.Inspector</serviceId>
    </service>

    <service>
        <name>flashorbInvoker</name>
        <serviceId>Weborb.Dispatch.Invoker</serviceId>
    </service>

    <service>
        <name>flashorbObjectHandler</name>
        <serviceId>Weborb.Handler.ObjectHandler</serviceId>
    </service>

    <service>
        <name>flashorbWebServiceHandler</name>
        <serviceId>Weborb.Handler.WebServiceHandler</serviceId>
    </service>
        
    <service>
        <name>serverInfo</name>
        <serviceId>Weborb.Console.Info.ServerInfo</serviceId>
    </service>
    
    <service>
        <name>Administration</name>
        <serviceId>Weborb.Config.Administration</serviceId>
    </service>

    <service>
        <name>CallTraceBrowser</name>
        <serviceId>Weborb.Console.CallMonitor.CallTraceBrowser</serviceId>
    </service>

    <service>
        <name>ORBSecurity</name>
        <serviceId>Weborb.Security.ORBSecurity</serviceId>
    </service>

    <service>
        <name>SingleIPRestriction</name>
        <serviceId>Weborb.Security.SingleIPRestriction</serviceId>
    </service>

    <service>
        <name>IPRangeRestriction</name>
        <serviceId>Weborb.Security.IPRangeRestriction</serviceId>
    </service>

    <service>
        <name>HostNameRestriction</name>
        <serviceId>Weborb.Security.HostNameRestriction</serviceId>
    </service>

    <service>
        <name>RoleNameRestriction</name>
        <serviceId>Weborb.Security.RoleNameRestriction</serviceId>
    </service>
    
    <service>
        <name>autoupdater</name>
        <serviceId>Weborb.Service.AutoUpdater</serviceId>
    </service>    
    
    <!-- Examples  -->
    <service>
        <name>ExamplesActivationSession</name>
        <serviceId>Examples.Activation.ShoppingCart</serviceId>
    </service>

    <service>
        <name>ExamplesActivationApplication</name>
        <serviceId>Examples.Activation.UserPoll</serviceId>
    </service>

    <service>
        <name>ExamplesFactoriesService</name>
        <serviceId>Examples.Invocation.Factories.Person</serviceId>
    </service>

    <service>
        <name>ExampleArgumentFactories</name>
        <serviceId>Examples.Invocation.Factories.SampleArgumentFactoryService</serviceId>
    </service>

    <service>
        <name>ExamplesBroadcast</name>
        <serviceId>Examples.Messageserver.Broadcast</serviceId>
    </service>

    <service>
        <name>ExamplesUnicast</name>
        <serviceId>Examples.Messageserver.Unicast</serviceId>
    </service>

    <service>
        <name>ExamplesSerializeCollections</name>
        <serviceId>Examples.Serialization.SerializeCollections</serviceId>
    </service>

    <service>
        <name>ExamplesSerializeComplexTypes</name>
        <serviceId>Examples.Serialization.SerializeComplexTypes</serviceId>
    </service>

    <service>
        <name>ExamplesSerializePrimitives</name>
        <serviceId>Examples.Serialization.SerializePrimitives</serviceId>
    </service>

    <service>
        <name>ExamplesSerializeStrings</name>
        <serviceId>Examples.Serialization.SerializeStrings</serviceId>
    </service>
    
    <service>
        <name>database</name>
        <serviceId>Examples.Flex.sqladmin.DatabaseService</serviceId>
    </service>

    <service>
        <name>computerinfo</name>
        <serviceId>weborb.examples.quickstart.ComputerInfoService</serviceId>
    </service>

    <service>
        <name>carrentalservice</name>
        <serviceId>Examples.Flex.carrental.CarRentalService</serviceId>
    </service>      
    
    <service>
        <name>samples.contact.Contact</name>
        <serviceId>Examples.Flex.contact.Contact</serviceId>
    </service>  
    
  </services>
  
  
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========       S E R V I C E    A C T I V A T O R S        ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
  Service activator is responsible for creating or retrieving an instance of .NET object
  accordingly to a policy. Before a service invocation takes place, an object needs to be
  constructed or retrieved. For example, Session activator retrieves a service object from 
  the HTTP session associated with the client.
  To register an activator, create <activator> element. The <activationModeName> element
  must contain the name of the activation mode the activator will be responding to. The
  <className> element must contain the name of the activator class. The class must implement
  the Weborb.Activation.IActivator interface and must have default no-argument constructor.
  ==================================================================================== -->
  <activators>
    <activator>
      <activationModeName>request</activationModeName>
      <className>Weborb.Activation.RequestActivator</className>
    </activator>

    <activator>
      <activationModeName>session</activationModeName>
      <className>Weborb.Activation.SessionActivator</className>
    </activator>

    <activator>
      <activationModeName>application</activationModeName>
      <className>Weborb.Activation.ApplicationActivator</className>
    </activator>
  </activators>
  
  
  
  
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========       S E R V I C E    I N S P E C T O R S        ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
   Enter inspector full type name in the <serviceInspector> element.
   Create a separate element for each new service inspector. WebORB uses
   reflection to create instances of custom inspectors. Inspector class must
   have a default no-arg constructor and must implement the
   Weborb.Handler.IInspectionHandler interface
   ==================================================================================== -->
  <inspectors>
    <serviceInspector>Weborb.Handler.ObjectHandler</serviceInspector>
    <serviceInspector>Weborb.Handler.WebServiceHandler</serviceInspector>
    <!-- <serviceInspector>Weborb.Handler.CFCHandler</serviceInspector> -->
  </inspectors>  
 
 
 
 
 

  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========       S E R V I C E    I N V O K E R S            ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
  Enter invoker full type name in the <serviceInvoker> element.
  Create new element for each invoker class. WebORB uses reflection to
  create instances of custom invokers. Invoker class must have default no-arg
  constructor and must implement the Weborb.Handler.IInvocationHandler
  interface
  ==================================================================================== -->
  <invokers>
    <serviceInvoker>Weborb.Handler.ObjectHandler</serviceInvoker>
    <serviceInvoker>Weborb.Handler.WebServiceHandler</serviceInvoker>   
    <!-- <serviceInvoker>Weborb.Handler.CFCHandler</serviceInvoker> -->
  </invokers>
 
 
 
 
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========      S E R V I C E   F A C T O R I E S            ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
   Service object factories are responsible for creating new instances of
   objects on which the invocations will take place. By default WebORB
   uses default no-arg constructor to create new instances. Using service
   object factory overrides that mechanism.
   ==================================================================================== -->
  <serviceFactories>
    <!--
     Each service object factory must be declared using the <serviceFactory>
     element. Each element must contain full type name for the actual service 
     object factory class and fully qualified classname for the class (interface) 
     the factory is responsible for creating.
    -->
    <serviceFactory>
      <!-- full type name of the service object. The class must implement 
      Weborb.Util.IServiceObjectFactory -->
      <serviceFactoryClassName></serviceFactoryClassName>
      <!-- fully qualified class name the service object
      factory is responsible for constructing -->
      <className></className>
    </serviceFactory>
    
    <serviceFactory>
      <serviceFactoryClassName>Weborb.Security.ORBSecurityFactory</serviceFactoryClassName>
      <className>Weborb.Security.ORBSecurity</className>
    </serviceFactory>    
  </serviceFactories>
 
 
 
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========      A R G U M E N T   F A C T O R I E S          ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
   Argument object factories are responsible for creating new instances of
   method arguments which will be passed into method invocations. By default WebORB
   uses argument adaptation logic where Flash ActionScript data types are converted
   into the argument types of the invoked method. Using argument object factories
   overrides the default adaptation logic mechanism.
   ==================================================================================== -->
  <argumentFactories>
    <!--
     Eeach argument object factory must be declared using the <argumentFactory>
     element. Each element must contain type name for the actual argument object 
     factory class and name for the class (interface) the factory is responsible 
     for creating.
    -->
    <argumentFactory>
      <!-- class name of the service object. The class must implement 
      Weborb.Util.IArgumentObjectFactory -->
      <argumentFactoryClassName>Weborb.Security.RestrictionFactory</argumentFactoryClassName>
      <!-- Name of the class the service object factory is responsible for constructing -->
      <className>Weborb.Security.IRestriction</className>
    </argumentFactory>
    
    <argumentFactory>
      <argumentFactoryClassName>Weborb.Util.Logging.Policies.LoggingPolicyFactory</argumentFactoryClassName>
      <className>Weborb.Util.Logging.ILoggingPolicy</className>
    </argumentFactory>    

    <argumentFactory>
      <argumentFactoryClassName>Weborb.V3Types.BodyHolderFactory</argumentFactoryClassName>
      <className>Weborb.V3Types.BodyHolder</className>
    </argumentFactory>    

    <argumentFactory>
      <argumentFactoryClassName>Weborb.Service.ArrayUpdateDataObjectFactory</argumentFactoryClassName>
      <className>Weborb.Service.ArrayUpdateData</className>
    </argumentFactory>    

  </argumentFactories>      
  


<!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========       A B S T R A C T    M A P P I N G S          ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
  If an abstract class or an interface is used an argument type in a method invocation,
  a concrete class must be used to represent the interface or the abstract class.  
  The abstract class mapping feature is designed to map non-abstract class to an interface 
  or abstract class it implements or extends.
  To create an abstract type mapping, use the <abstractClassMapping> element. The <className>
  subelement must define the name of an abstract class or an interface. The <mappedClassName>
  element must contain the name of the concrete class providing an implementation of the
  specified interface or the abstract class.
  ==================================================================================== -->
  <abstractClassMappings>
    <abstractClassMapping>
        <className>System.Collections.ICollection</className>
        <mappedClassName>System.Collections.ArrayList</mappedClassName>
    </abstractClassMapping>

    <abstractClassMapping>
        <className>System.Collections.IList</className>
        <mappedClassName>System.Collections.ArrayList</mappedClassName>
    </abstractClassMapping>

    <abstractClassMapping>
        <className>System.Collections.IDictionary</className>
        <mappedClassName>System.Collections.Hashtable</mappedClassName>
    </abstractClassMapping>
  </abstractClassMappings>
  
  
  
  
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========   C U S T O M   T Y P E   S E R I A L I Z E R S   ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
  Type serializers are responsible for writing .NET objects to the AMF format. WebORB
  provides support for most common types as well as an ability to override or extend the
  default behavior.
  Use <customWriter> element to register new custom serializers. Each writer must be declared
  as a mapping between the type it is responsible for serializing objects of class defined in \
  <className> and the class name of the actual writer class <writerClassName>. 
  Custom writer class must implement the Weborb.Writer.ITypeWriter interface and must 
  have default no-argument constructor
  ==================================================================================== -->
  <customWriters>
    <!--
    <customWriter>
        <className></className>
        <writerClassName></writerClassName>
    </customWriter>
    -->  
    <customWriter>
        <className>Weborb.Server.Channel.SubscriberInfo</className>
        <writerClassName>Weborb.Server.Channel.SubscriberInfoWriter</writerClassName>
    </customWriter>

    <customWriter>
        <className>Weborb.Server.Channel.SubscribersEvent</className>
        <writerClassName>Weborb.Server.Channel.SubscribersEventWriter</writerClassName>
    </customWriter> 
    
    <customWriter>
        <className>Weborb.V3Types.BodyHolder</className>
        <writerClassName>Weborb.V3Types.BodyHolderWriter</writerClassName>
    </customWriter> 
  </customWriters>
  
  
  
  
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========     S E R I A L I Z A T I O N    P R O P S        ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
  This section contains various serialization related configuration settings. It is mostly
  a placeholder for future config items  
  ==================================================================================== -->
  <serialization>
    <serializePrivateFields>no</serializePrivateFields>
  </serialization>




 <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========                 D A T A S E T S                   ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
  Currently there is only one configuration property related to the data set serialization. 
  The property is <defaultPageSize> and it controls how many records from data tables 
  are returned with the first request.  
  ==================================================================================== -->
  <datasets>
    <defaultPageSize>10</defaultPageSize>
  </datasets>



    
 <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========                 S E C U R I T Y                   ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
  Security configuration consists of declaration of protected resources and
  access constraints. The resources are described by the <secure-resource>
  elements, access constraints are defined with the <access-constraint>
  element. Access constraints are not coupled to the resources, these are
  generic definitions of access limitations. One can define multiple constraints
  for the group of users/computers. A resource lists all the applicable
  constraints via the <constrain-name> elements.
  ==================================================================================== -->
  <security>
  <!--
    the <deploymentMode> element controls how the classes and assemblies in the WebORB-enabled
    application are exposed to the flash remoting clients.
    The 'open system' deployment mode exposes ALL classes in the application to Flash clients. 
    Security restrictions for the individual methods, classes and namespaces can still apply.
    The 'closed system' deployment model denies access to ALL classes except for the ones explicitly
    exposed with the <secure-resource> elements. 
    -->
    <deploymentMode>open</deploymentMode>

    <!--
    Authentication handler is responsible for authenticating user credentials passed along
    with an invocation. If specified, the handler is invoked every time when the credentials
    are passed along with an invocation. Handler invocation takes place before any WebORB 
    does and invocation processing. If the credentials cannot be authenticated, 
    FlashORBAuthenticationException must be thrown to indicate the failure. Error message 
    and error code from passed into the exception constructor are delivered to the client.
    Class specified in the authenticationHandler must implement the Weborb.Security.IAuthenticationHandler
    interface.
    -->
    <authenticationHandler></authenticationHandler>

    <!--
    Authorization handler is responsible for making a decision whether a request to access a resource
    should be allowed. The default implementation of the authorization handler checks if any of the 
    access constraints associated with the resource grant or deny access to the resource. 
    An authorization handler must implement the Weborb.Security.IAuthorizationHandler interface and 
    must have a default no-argument constructor. To override the global authorization handler, 
    individual services may have their own service-level authorization handler. If one is specified, 
    it takes priority over the the global handler when the resource is accessed.
    -->
    <authorizationHandler>Weborb.Security.WebORBAuthorizationHandler</authorizationHandler>
    
    <secure-resources>
      <secure-resource>
        <!--
        method - name of the method in the format of serviceid.methodname
        service - id of the service to secure (fully qualified class name, WSDL URL)
        assembly name - name of the assembly to secure with the specified containt(s)
        namespace - name of the namespace, in the form of My.Assembly.*        
        named service - name of the resource as it is defined in the named services section
        -->
        <resource>ORBSecurity</resource>

        <!--
        Specify the name of a constraint to secure the resource.
        Multiple constraint-name elements are allowed
        -->
        <constraint-name>localhost constraint</constraint-name>
      </secure-resource>
      <secure-resource>
         <resource>weborb.tests.*</resource>
         <constraint-name>everyone</constraint-name>
      </secure-resource>
      
      <!-- 
      ****************************************************
      Security declaration for the system level resources.
      These declarations must be present in the config file
      when WebORB runs in the 'closed system' mode.
      The default access level is 'everyone', thus exposing
      WebORB itself (but not the deployed application) to
      all potential clients. 
      *****************************************************
      -->
      <secure-resource>
         <resource>flashorbHttpHandler</resource>
         <constraint-name>everyone</constraint-name>
      </secure-resource>
      <secure-resource>
         <resource>flashorbInspector</resource>
         <constraint-name>everyone</constraint-name>
      </secure-resource>
      <secure-resource>
         <resource>flashorbInvoker</resource>
         <constraint-name>everyone</constraint-name>
      </secure-resource>
      <secure-resource>
         <resource>flashorbObjectHandler</resource>
         <constraint-name>everyone</constraint-name>
      </secure-resource>
      <secure-resource>
         <resource>flashorbWebServiceHandler</resource>
         <constraint-name>everyone</constraint-name>
      </secure-resource>                  
      <!-- end of system level resources -->

      <secure-resource>
         <resource>serverInfo</resource>
         <constraint-name>localhost constraint</constraint-name>
      </secure-resource>
      <secure-resource>
         <resource>Administration</resource>
         <constraint-name>localhost constraint</constraint-name>
      </secure-resource>
      <secure-resource>
         <resource>CallTraceBrowser</resource>
         <constraint-name>localhost constraint</constraint-name>
      </secure-resource>      
      <secure-resource>
         <resource>SingleIPRestriction</resource>
         <constraint-name>localhost constraint</constraint-name>
      </secure-resource>        
      <secure-resource>
         <resource>IPRangeRestriction</resource>
         <constraint-name>localhost constraint</constraint-name>
      </secure-resource>        
      <secure-resource>
         <resource>HostNameRestriction</resource>
         <constraint-name>localhost constraint</constraint-name>
      </secure-resource>        
      <secure-resource>
         <resource>RoleNameRestriction</resource>
         <constraint-name>localhost constraint</constraint-name>
      </secure-resource>        
      <secure-resource>
         <resource>System.*</resource>
         <constraint-name>localhost constraint</constraint-name>
      </secure-resource>
      <secure-resource>
         <resource>Microsoft.*</resource>
         <constraint-name>localhost constraint</constraint-name>
      </secure-resource>
    </secure-resources>

    <access-constraints>
      <!--
      Define access constaints with the <access-constraint> elements.
      The action attribute is required. valid values are "grant" and "reject".
      A single access-constraint element may have a combination of the following
      constraints:
            - zero or more IP address
            - zero or more IP range
            - zero or more hostnames
            - zero or more user roles
            - zero or more java package name patterns
      A constraint element must have a name, so it can be reused for securing
      multiple resources
      -->
      <access-constraint action="grant">

        <!--
        Name of the access constraint
        -->
        <name>localhost constraint</name>
        <!--
        This can be either a single ip address (212.45.21.112)
        or a mask of ip addresses (212.45.*.*)
        Multiple IP elements allowed

        <IP></IP>
        -->

        <!--
        Range of ip addresses. Use either specific addresses or masks.
        Multiple IPrange elements allowed

        <IPrange>
          <subnet-address></subnet-address>
          <subnet-mask></subnet-mask>
        </IPrange>
        -->

        <!--
        this can be either a single hostname (themidnightcoders.com),
        or a pattern of host names (*.themidnightcoders.com)
        Multiple hostname elements allowed
        -->
        <hostname>localhost</hostname>

        <!--
        Define role-based access constrains using the role element. The roles must be
        defined using in acl.xml file. Multiple <role> elements allowed

        <role></role>
        -->
      </access-constraint>
      <access-constraint action="grant">
        <name>everyone</name>
        <IP>*.*.*.*</IP>
      </access-constraint>
    <access-constraint action="reject"><name>test constr</name><IP>1.1.1.1</IP></access-constraint></access-constraints>
  </security>
  
  <acl>
    <user>
        <name>admin</name>
        <password>changeme</password>
        <role>administrator</role>
    </user>
  </acl>
  
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========             C A L L   T R A C I N G               ================= -->
  <!-- ===========                                                   ================= -->
  <!-- ===============================================================================
   Call tracing is a server-side implementation of NetDebug events. When enabled,
  WebORB persistently stores information about every single invocation. The
  information includes the following data:
  - caller ID
  - http headers
  - targeted service
  - method name
  - invocation duration
  - method arguments
  - return value
  - flag whether invocation resulted in error
  There are several configuration properties related to call tracing. See
  comments for each of the configuration parameters below.
  Call tracing is enabled by default, however, it is recommended to turn
  this feature off in the production environment as it may impact the
  performance of the WebORB server under heavy load. To turn the feature
  off, change the value of the <enableCallTrace> element to 'no'
  ==================================================================================== -->
  <callTrace enable="no">

    <!--
    CallTraceDispatcher has a queue of where all the invocation requests get recorded.
    The dispatcher is responsible for notifying registered listeners about the
    collected calls. There are 2 ways the dispatcher gets activated. One if the
    number of messages in the queue (controlled by the queueFlushThreshold element),
    and the other is the number of milliseconds the dispatcher should wait before
    it wakes up and checks the queue for available calls.

    queueFlushThreshold indicates how many calls should be accumulated in the
    call trace event dispatcher before the calls are dispatched to all the registered
    listeners. An example of the call listener is CallTraceStore - the class
    responsible for persisting call trace objects.
    queueFlushThreshold cannot be 0. The smaller the threshold is more frequently
    the dispatcher notifies the listeners.
    -->
    <queueFlushThreshold>10</queueFlushThreshold>
    <!--
    queueCheckWaitTime is number of milliseconds call trace dispatcher should wait
    before checking the call queue for new calls. The number cannot be 0.
    -->
    <queueCheckWaitTime>5000</queueCheckWaitTime>

    <!--
    Path name of the directory where the call store files are stored
    -->
    <callStoreFolder>calltrace</callStoreFolder>

    <!--
    Size of the memory buffer where ongoing call objects are stored
    as soon as the buffer is filled up, the call objects are saved
    to the file system
    -->
    <callStoreBufferSize>51200</callStoreBufferSize>

    <!--
    Maximum number of call objects per each call store file. When the
    number is reached, the call store system rolls over to the next file
    -->
    <maxCallsPerCallStoreFile>100</maxCallsPerCallStoreFile>    
  </callTrace>  
      
  <!-- =============================================================================== -->
  <!-- ===========                                                   ================= -->
  <!-- ===========          M E S S A G E   S E R V E R              ================= -->
  <!-- ===========                                                   ================= -->
  <!-- =============================================================================== -->
  
  <messageServer>

    <handlerChains>
      <!--
      <handlerChain>        
        <factoryClass></factoryClass>        
        <preExecutionChain>
          <handlerClass></handlerClass>
          <handlerClass></handlerClass>
        </preExecutionChain>
        <postExecutionChain>
          <handlerClass></handlerClass>
          <handlerClass></handlerClass>
        </postExecutionChain>
      </handlerChain>
      -->

      <handlerChain>
        <!-- factory must be an instance of Weborb.Messageserver.IMessageFactory -->
        <factoryClass>Weborb.Server.Message.DefaultXMLMessageFactory</factoryClass>
        <!-- handlers must be instances of Weborb.Messageserver.IMessageHandler -->
        <postExecutionChain>
          <handlerClass>Weborb.Server.Message.Handler.MessageDeliveryHandler</handlerClass>
        </postExecutionChain>
      </handlerChain>

      <handlerChain>
        <factoryClass>Weborb.Server.Message.DefaultMessageFactory</factoryClass>
        <postExecutionChain>
          <handlerClass>Weborb.Server.Message.Handler.MessageDeliveryHandler</handlerClass>
        </postExecutionChain>
      </handlerChain>
    </handlerChains>

    <messageFactories>
      <serverDomain>
        <serverName>default</serverName>
        <port>9000</port>
        <defaultXMLMessageFactory>Weborb.Server.Message.DefaultXMLMessageFactory</defaultXMLMessageFactory>
        <messageFactory>
          <messageRootElement>join</messageRootElement>
          <factoryClassName>Weborb.Server.Message.System.JoinCommandMessageFactory</factoryClassName>
        </messageFactory>
        <messageFactory>
          <messageRootElement>deliverTo</messageRootElement>
          <factoryClassName>Weborb.Server.Message.System.DeliverCommandMessageFactory</factoryClassName>
        </messageFactory>
        <messageFactory>
          <messageRootElement>getSubscribers</messageRootElement>
          <factoryClassName>Weborb.Server.Message.System.GetSubscribersMessageFactory</factoryClassName>
        </messageFactory>
        <messageFactory>
          <messageRootElement>changeLogicalName</messageRootElement>
          <factoryClassName>Weborb.Server.Message.System.ChangeLogicalNameCommandMessageFactory</factoryClassName>
        </messageFactory>
      </serverDomain>
    </messageFactories>
  </messageServer>   
    
  </weborb>
</configuration>